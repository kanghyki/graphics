struct MaterialForShading {
    vec3 albedo;
    float specular_alpha;
    float shininess;
};

float CalcCSM(Light L, vec3 pos, vec3 normal, vec3 lightDir)
{
    if (!L.use_shadow)
    {
        return 0.0;
    }
    vec4 view_pos = t_view * vec4(pos, 1.0);
    float depth = abs(view_pos.z);
    
    int layer = -1;
    for (int i = 0; i < CASCADE_COUNT; ++i)
    {
        if (depth < L.cascade_distance[i])
        {
            layer = i;
            break;
        }
    }
    if (layer == -1)
    {
        layer = CASCADE_COUNT;
    }
    vec4 light_space_pos = L.csm_matrix[layer] * vec4(pos, 1.0);
    vec3 coords = light_space_pos.xyz / light_space_pos.w;
    coords = coords * 0.5 + 0.5;
    float currentDepth = coords.z;
    if (currentDepth  > 1.0)
    {
        return 0.0;
    }

    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    if (layer == CASCADE_COUNT)
    {
        bias *= 1 / (L.far_plane * 0.5f);
    }
    else
    {
        bias *= 1 / (L.cascade_distance[layer] * 0.5f);
    }

    float shadow = 0.0;
    vec2 texelSize = 1.0 / vec2(textureSize(l_shadow_array, 0));
    for(int x = -2; x <= 2; ++x)
    {
        for(int y = -2; y <= 2; ++y)
        {
            float pcfDepth = texture(l_shadow_array, vec3(coords.xy + vec2(x, y) * texelSize, layer)).r; 
            shadow += (currentDepth - bias) > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    shadow /= 25.0;
    if(coords.z > 1.0)
    {
        shadow = 0.0;
    }

    return shadow;
}

float CalcSpotShadow(Light L, vec3 pos, vec3 normal, vec3 lightDir)
{
    if (!L.use_shadow)
    {
        return 0.0;
    }
    vec4  light_ndc = L.proj * L.view * vec4(pos, 1.0);
    vec3  coords    = (light_ndc.xyz / light_ndc.w) * 0.5 + 0.5;
    float depth     = coords.z;
    float bias      = max(0.02 * (1.0 - dot(normal, lightDir)), 0.001);
    vec2  texelSize = 1.0 / textureSize(l_shadow[L.shadow_id], 0);
    float shadow    = 0.0;

    for(int x = -2; x <= 2; ++x)
    {
        for (int y = -2; y <= 2; ++y)
        {
            float tex_depth = texture(l_shadow[L.shadow_id], coords.xy + vec2(x, y) * texelSize).r;
            shadow += (depth - bias > tex_depth ? 1.0 : 0.0);
        }
    }
    shadow /= 25.0;

    return shadow;
}

#define SAMPLE_OFFSET_COUNT (20)
vec3 sample_offset_dir[SAMPLE_OFFSET_COUNT] = vec3[]
(
   vec3(1, 1, 1),  vec3(1, -1, 1),  vec3(-1, -1, 1),  vec3(-1, 1, 1), 
   vec3(1, 1, -1), vec3(1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1, 0),  vec3(1, -1, 0),  vec3(-1, -1, 0),  vec3(-1, 1, 0),
   vec3(1, 0, 1),  vec3(-1, 0, 1),  vec3(1, 0, -1),   vec3(-1, 0, -1),
   vec3(0, 1, 1),  vec3(0, -1, 1),  vec3(0, -1, -1),  vec3(0, 1, -1)
); 

float CalcPointShadow(Light L, vec3 pos)
{
    if (!L.use_shadow)
    {
      return 0.0;
    }
    vec3    pos_to_light    = pos - L.position;
    float   depth           = length(pos_to_light);
    float   tex_depth       = texture(l_shadow_cube[L.shadow_id], normalize(pos_to_light)).r * L.far_plane;
    float   shadow          = 0.0;
    float   bias            = 0.15;
    float   view_dist       = length(c_view_position - pos);
    float   disk_radius     = (1.0 + (view_dist / L.far_plane)) / L.far_plane;  
    for(int i = 0; i < SAMPLE_OFFSET_COUNT; ++i)
    {
        float tex_depth = texture(l_shadow_cube[L.shadow_id], pos_to_light + sample_offset_dir[i] * disk_radius).r;
        tex_depth *= L.far_plane;
        shadow += (depth - bias > tex_depth ? 1.0 : 0.0);
    }
    shadow /= float(SAMPLE_OFFSET_COUNT);  

    return shadow;
}  

vec3 BlinnPhong(vec3 light_color, vec3 light_vec, vec3 normal, vec3 to_eye, MaterialForShading mat)
{
    vec3 halfway = normalize(to_eye + light_vec);
    float hdotn = dot(halfway, normal);
    vec3 specular = mat.albedo * pow(max(hdotn, 0.0f), mat.shininess);

    return (mat.albedo + (specular * mat.specular_alpha)) * light_color;
}

vec3 ComputeDirectionalLight(Light L, MaterialForShading mat, vec3 pos, vec3 normal, vec3 to_eye)
{
    vec3 light_vec = -L.direction;

    float ndotl = max(dot(light_vec, normal), 0.0f);
    vec3 lightStrength = L.color * L.strength * ndotl;

    float shadow = CalcCSM(L, pos, normal, light_vec);

    return BlinnPhong(lightStrength, light_vec, normal, to_eye, mat) * (1.0 - shadow);
}

float CalcAttenuation(float d, float falloff_start, float falloff_end)
{
    return clamp((falloff_end - d) / (falloff_end - falloff_start), 0.0, 1.0);
}

vec3 ComputePointLight(Light L, MaterialForShading mat, vec3 pos, vec3 normal, vec3 to_eye)
{
    vec3 light_vec = L.position - pos;
    float d = length(light_vec);
    if (d > L.falloff_end)
    {
        return vec3(0.0, 0.0, 0.0);
    }
    light_vec /= d;

    float ndotl = max(dot(light_vec, normal), 0.0f);
    vec3 lightStrength = L.color * L.strength * ndotl;

    float att = CalcAttenuation(d, L.falloff_start, L.falloff_end);
    lightStrength *= att;

    float shadow = CalcPointShadow(L, pos);

    return BlinnPhong(lightStrength, light_vec, normal, to_eye, mat) * (1.0 - shadow);
}

vec3 ComputeSpotLight(Light L, MaterialForShading mat, vec3 pos, vec3 normal, vec3 to_eye)
{
    vec3 light_vec = L.position - pos;
    float d = length(light_vec);
    if (d > L.falloff_end)
    {
        return vec3(0.0f, 0.0f, 0.0f);
    }
    light_vec /= d;

    float ndotl = max(dot(light_vec, normal), 0.0f);
    vec3 light_color = L.color * L.strength * ndotl;

    float att = CalcAttenuation(d, L.falloff_start, L.falloff_end);
    light_color *= att;

    float spot_factor = pow(max(-dot(light_vec, L.direction), 0.0f), L.spot_power);
    light_color *= spot_factor;

    float shadow = CalcSpotShadow(L, pos, normal, light_vec);

    return BlinnPhong(light_color, light_vec, normal, to_eye, mat) * (1.0 - shadow);
}