struct MaterialForShading {
    vec3 albedo;
    float specular_alpha;
    float shininess;
};

float CalcShadow2D(Light L, vec3 position, vec3 normal, vec3 lightDir) {
    vec4  lightPosition   = L.proj * L.view * vec4(position, 1.0);
    vec3  depthMapCoords  = (lightPosition.xyz / lightPosition.w) * 0.5 + 0.5;
    float closestDepth    = texture(l_shadow[L.shadow_id], depthMapCoords.xy).r;
    float currentDepth    = depthMapCoords.z;
    float bias            = max(0.02 * (1.0 - dot(normal, lightDir)), 0.001);
    float shadow          = 0.0;
    vec2  texelSize       = 1.0 / textureSize(l_shadow[L.shadow_id], 0);
    int   count           = 1;

    for(int x = -1; x <= 1; ++x) {
        for (int y = -1; y <= 1; ++y) {
            float pcfDepth = texture(l_shadow[L.shadow_id], depthMapCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
            ++count;
        }
    }
    shadow /= count;

    return shadow;
}

vec3 BlinnPhong(vec3 light_color, vec3 light_vec, vec3 normal, vec3 to_eye, MaterialForShading mat)
{
    vec3 halfway = normalize(to_eye + light_vec);
    float hdotn = dot(halfway, normal);
    vec3 specular = mat.albedo * pow(max(hdotn, 0.0f), mat.shininess);

    return (mat.albedo + (specular * mat.specular_alpha)) * light_color;
}

vec3 ComputeDirectionalLight(Light L, MaterialForShading mat, vec3 normal, vec3 to_eye)
{
    vec3 light_vec = -L.direction;

    float ndotl = max(dot(light_vec, normal), 0.0f);
    vec3 lightStrength = L.color * L.strength * ndotl;

    return BlinnPhong(lightStrength, light_vec, normal, to_eye, mat);
}

float CalcAttenuation(float d, float falloff_start, float falloff_end)
{
    return clamp((falloff_end - d) / (falloff_end - falloff_start), 0.0, 1.0);
}

vec3 ComputePointLight(Light L, MaterialForShading mat, vec3 pos, vec3 normal, vec3 to_eye)
{
    vec3 light_vec = L.position - pos;
    float d = length(light_vec);
    if (d > L.falloff_end)
    {
        return vec3(0.0, 0.0, 0.0);
    }
    else
    {
        light_vec /= d;

        float ndotl = max(dot(light_vec, normal), 0.0f);
        vec3 lightStrength = L.color * L.strength * ndotl;

        float att = CalcAttenuation(d, L.falloff_start, L.falloff_end);
        lightStrength *= att;

        return BlinnPhong(lightStrength, light_vec, normal, to_eye, mat);
    }
}

vec3 ComputeSpotLight(Light L, MaterialForShading mat, vec3 pos, vec3 normal, vec3 to_eye)
{
    vec3 light_vec = L.position - pos;
    float d = length(light_vec);
    if (d > L.falloff_end)
    {
        return vec3(0.0f, 0.0f, 0.0f);
    }
    else
    {
        light_vec /= d;

        float ndotl = max(dot(light_vec, normal), 0.0f);
        vec3 light_color = L.color * L.strength * ndotl;

        float att = CalcAttenuation(d, L.falloff_start, L.falloff_end);
        light_color *= att;

        float spot_factor = pow(max(-dot(light_vec, L.direction), 0.0f), L.spot_power);
        light_color *= spot_factor;

        float shadow = CalcShadow2D(L, pos, normal, light_vec);

        return BlinnPhong(light_color, light_vec, normal, to_eye, mat) * (1.0 - shadow);
    }
}